from snakemake.utils import min_version
import os
import shutil
import numpy as np
import pandas as pd

##### set minimum snakemake version #####
min_version("6.0.0")

##### load rules ##########
include: "rules/common.smk"

workdir: config["outdir"]

samplesheet = pd.read_csv(
    config["samplesheet"],
    sep="\t",
    dtype={
        "sampleID": str,
        "condition": str,
        "group": str,
        "read1": str,
        "read2": str,
    },
).set_index("sampleID")

# check the sample names are unique
assert len(np.unique(samplesheet.index.tolist())) == len(samplesheet.index.tolist()), "sampleIDs in the samplesheet are not unique"

# validate IgG control setup if enabled
if config["igg_control"]:
    groups = samplesheet["group"].unique()
    for group in groups:
        group_samples = samplesheet[samplesheet["group"] == group]
        controls = group_samples[group_samples["condition"] == "Control"]
        experiments = group_samples[group_samples["condition"] != "Control"]

        assert len(controls) == 1, f"Group '{group}' must have exactly one Control sample when igg_control=true, found {len(controls)}"
        assert len(experiments) >= 1, f"Group '{group}' must have at least one experimental sample when igg_control=true, found {len(experiments)}"

logdir = config["outdir"] + "/logs"
if not os.path.exists(logdir):
    os.makedirs(logdir)

SAMPLES = samplesheet.index.tolist()
EXPERIMENT = samplesheet[samplesheet["condition"] != "Control"].index.tolist()
CONTROL = samplesheet[samplesheet["condition"] == "Control"].index.tolist()

rule all:
    input:
        expand("qc/{sample}_1", sample=SAMPLES),
        expand("qc/{sample}_2", sample=SAMPLES),
        "stats/stats.txt",
        "stats/fragments.pdf",
        "stats/replicates.pdf",
        "stats/peaks_consolidated.txt",
        "stats/seacr/peaks_fig.pdf",
        "stats/macs3/peaks_fig.pdf",
        expand("stats/seacr/{sample}.heatmap.png", sample=EXPERIMENT),


rule check_quality:
    input:
        r1="trimmed/{sample}_val_1.fq.gz" if config["trim_adapters"] else r1_from_sample,
        r2="trimmed/{sample}_val_2.fq.gz" if config["trim_adapters"] else r2_from_sample,
    output:
        out1=directory("qc/{sample}_1"),
        out2=directory("qc/{sample}_2"),
    log:
        "logs/check_quality/{sample}.log",
    conda:
        "envs/fastqc.yaml"
    shell:
        """
        mkdir -p {output.out1} {output.out2} && fastqc -o {output.out1} {input.r1} && fastqc -o {output.out2} {input.r2}
        """


rule trim_adapters:
    input:
        r1=r1_from_sample,
        r2=r2_from_sample,
    output:
        out1="trimmed/{sample}_val_1.fq.gz",
        out2="trimmed/{sample}_val_2.fq.gz",
    log:
        "logs/trim_adapters/{sample}.log",
    conda:
        "envs/trim_galore.yaml"
    shell:
        """
        trim_galore --gzip --trim-n -o trimmed --basename {wildcards.sample} --paired {input.r1} {input.r2}
        """


rule align_reads:
    input:
        ref=config["reference_fa"],
        r1="trimmed/{sample}_val_1.fq.gz" if config["trim_adapters"] else r1_from_sample,
        r2="trimmed/{sample}_val_2.fq.gz" if config["trim_adapters"] else r2_from_sample,
    output:
        sam=temp("alignments/{sample}.sam"),
        log="alignments/{sample}.alignments.txt",
    log:
        "logs/align_reads/{sample}.log",
    conda:
        "envs/bowtie.yaml"
    threads: 8
    params:
        aln="--local" if config["trim_adapters"] else "--end-to-end",
        ref=config["bt2_idx"],
    shell:
        """
        bowtie2 {params.aln} --very-sensitive --no-mixed --no-discordant --phred33 -I {config[fragment_min]} -X {config[fragment_max]} -p {threads} -x {params.ref} -1 {input.r1} -2 {input.r2} -S {output.sam} |& tee {output.log}
        """


rule convert_to_binary:
    input:
        "alignments/{sample}.sam",
    output:
        bam="alignments/{sample}.sorted.bam",
    log:
        "logs/convert_to_binary/{sample}.log",
    conda:
        "envs/samtools.yaml"
    threads: 2
    shell:
        """
        samtools view -S -b {input} | samtools sort -@ {threads} -o {output.bam}
        """


rule index_bam:
    input:
        bam="alignments/{sample}.sorted.bam",
    output:
        bai="alignments/{sample}.sorted.bam.bai",
    log:
        "logs/index_bam/{sample}.log",
    conda:
        "envs/samtools.yaml"
    shell:
        """
        samtools index {input.bam}
        """


rule remove_duplicates:
    input:
        bam="alignments/{sample}.sorted.bam",
        bai="alignments/{sample}.sorted.bam.bai",
    output:
        bam="dedupalignments/{sample}.sorted.bam",
        metrics="dedupalignments/{sample}.rmdup.txt",
    log:
        "logs/remove_duplicates/{sample}.log",
    conda:
        "envs/picard.yaml"
    shell:
        """
        mkdir -p dedupalignments
        picard MarkDuplicates -I {input.bam} -O {output.bam} -METRICS_FILE {output.metrics} -REMOVE_DUPLICATES true
        """


use rule index_bam as index_dedup_bam with:
    input:
        bam="dedupalignments/{sample}.sorted.bam",
    output:
        bai="dedupalignments/{sample}.sorted.bam.bai",
    log:
        "logs/index_dedup_bam/{sample}.log",


rule find_mtdna_reads:
    input:
        bam="alignments/{sample}.sorted.bam",
        bai="alignments/{sample}.sorted.bam.bai",
    output:
        "alignments/{sample}.mtdna.txt",
    log:
        "logs/find_mtdna_reads/{sample}.log",
    conda:
        "envs/samtools.yaml"
    params:
        mtdna=config["mt_chrom"],
    shell:
        """
        samtools view -f0x40 {input.bam} {params.mtdna} | wc -l > {output}
        """


rule find_ecoli_reads:
    input:
        ref=config["ecoli_reference"],
        r1="trimmed/{sample}_val_1.fq.gz" if config["trim_adapters"] else r1_from_sample,
        r2="trimmed/{sample}_val_2.fq.gz" if config["trim_adapters"] else r2_from_sample,
    output:
        sam=temp("alignments/{sample}.ecoli.sam"),
        txt="alignments/{sample}.ecoli.txt",
    log:
        "logs/find_ecoli_reads/{sample}.log",
    conda:
        "envs/bowtie.yaml"
    threads: 4
    params:
        ref=config["ecoli_bt2_idx"],
    shell:
        """
        bowtie2 --end-to-end --very-sensitive --no-mixed --no-discordant --phred33 -I {config[fragment_min]} -X {config[fragment_max]} -p {threads} -x {params.ref} -1 {input.r1} -2 {input.r2} -S {output.sam} &> {output.txt}
        """


rule report_on_alignments:
    input:
        aln=expand("alignments/{sample}.alignments.txt", sample=SAMPLES),
        mtn=expand("alignments/{sample}.mtdna.txt", sample=SAMPLES),
        dup=expand("dedupalignments/{sample}.rmdup.txt", sample=SAMPLES),
        eco=expand("alignments/{sample}.ecoli.txt", sample=SAMPLES),
    output:
        report("stats/stats.txt", caption="report/alignment.rst"),
    log:
        "logs/report_on_alignments/job.log",
    conda:
        "envs/R.yaml"
    script:
        "scripts/run_alignment_report.R"


rule fragment_size:
    input:
        "alignments/{sample}.sorted.bam",
    output:
        "alignments/{sample}.fraglengths.txt",
    log:
        "logs/fragment_size/{sample}.log",
    conda:
        "envs/samtools.yaml"
    shell:
        """
        samtools view -F 0x04 {input} | awk -F"\\t" 'function abs(x){{return ((x < 0.0) ? -x : x)}} {{print abs($9)}}' | sort | uniq -c | awk -v OFS="\\t" '{{print $2, $1/2}}' > {output} 
        """


rule viz_fragment_size:
    input:
        expand("alignments/{sample}.fraglengths.txt", sample=SAMPLES),
    output:
        report("stats/fragments.pdf", caption="report/fragments.rst"),
    log:
        "logs/viz_fragment_size/plot.log",
    conda:
        "envs/R.yaml"
    script:
        "scripts/viz_fragment_size.R"


# we filter all reads overlapping the blacklist, remove non-primary and sex
# chromosomes and remove low-quality reads to create the bedgraph file which
# is given to the peak caller
rule bam_to_bed:
    input:
        fai=config["reference_fai"],
        blklist=config["blacklist"],
        bai=(
            "dedupalignments/{sample}.sorted.bam.bai"
            if config["dedup"]
            else "alignments/{sample}.sorted.bam.bai"
        ),
        bam=(
            "dedupalignments/{sample}.sorted.bam"
            if config["dedup"]
            else "alignments/{sample}.sorted.bam"
        ),
    output:
        bam=temp("{sample}.name.bam"),
        qbam=(
            "dedupalignments/{sample}.sorted.qflt.bam"
            if config["dedup"]
            else "alignments/{sample}.sorted.qflt.bam"
        ),
        qbai=(
            "dedupalignments/{sample}.sorted.qflt.bam.bai"
            if config["dedup"]
            else "alignments/{sample}.sorted.qflt.bam.bai"
        ),
        bed=temp("bedalignments/{sample}.bed"),
        bedgraph="bedalignments/{sample}.bedgraph",
        binbed="bedalignments/{sample}.bin.bed",
    log:
        "logs/bam_to_bed/{sample}.log",
    params:
        chroms=config["chromosome_file"],
        minq=config["minquality"],
    conda:
        "envs/bedtools.yaml"
    shell:
        """
        samtools view -h -q {params.minq} -f 1 -F 3852 {input.bam} $(tr '\\n' ' ' < {params.chroms}) \
        | awk -F "\\t" '/^@/ {{print; next}} ($7=="=" && $9 <= 1000 && $9 >= -1000) {{print}}' \
        | samtools view -b \
        | bedtools intersect -abam - -b {input.blklist} -v \
        > {output.qbam}

        samtools index {output.qbam}

        samtools sort -@ {threads} -n -O BAM -o {output.bam} {output.qbam} 

        bedtools bamtobed -i {output.bam} -bedpe \
        | cut -f 1,2,6 \
        | sort -k1,1 -k2,2n -k3,3n  \
        > {output.bed}

        bedtools genomecov -bg -i {output.bed} \
            -g <(cut -f 1,2 {input.fai}) > {output.bedgraph}

        awk -v w=500 '{{print $1, int(($2 + $3)/(2*w))*w + w/2}}' {output.bed} \
        | sort -k1,1V -k2,2n \
        | uniq -c \
        | awk -v OFS="\\t" '{{print $2, $3, $1}}' \
        |  sort -k1,1V -k2,2n  > {output.binbed}
        """

rule assess_replicates:
    input:
        expand("bedalignments/{sample}.bin.bed", sample=SAMPLES),
    output:
        report("stats/replicates.pdf", caption="report/replicates.rst"),
    log:
        "logs/assess_replicates/plot.log",
    conda:
        "envs/R.yaml"
    script:
        "scripts/viz_replicates.R"

rule call_seacr_peaks:
    input:
        con=get_bedg_control if config["igg_control"] else [],
        exp="bedalignments/{sample}.bedgraph",
    output:
        "peaks/seacr/{sample}.peaks.stringent.bed",
    log:
        "logs/call_seacr_peaks/{sample}.log",
    conda:
        "envs/seacr.yaml"
    params:
        prefix="peaks/seacr/{sample}.peaks",
        has_igg=config["igg_control"],
    shell:
        """
        if [ {params.has_igg} == True ]; then
            bash `which SEACR_1.3.sh` {input.exp} {input.con} norm stringent {params.prefix} || true
        else
            bash `which SEACR_1.3.sh` {input.exp} {config[seacr_qvalue]} norm stringent {params.prefix} || true
        fi
        if [ ! -f {output} ]; then
            touch {output}
        fi
        """

rule call_macs_peaks:
    input:
        con=get_bam_control if config["igg_control"] else [],
        exp=(
            "dedupalignments/{sample}.sorted.qflt.bam"
            if config["dedup"]
            else "alignments/{sample}.sorted.qflt.bam"
        ),
        expi=(
            "dedupalignments/{sample}.sorted.qflt.bam.bai"
            if config["dedup"]
            else "alignments/{sample}.sorted.qflt.bam.bai"
        ),
    output:
        sbed="peaks/macs3/{sample}_summits.bed",
        npeaks="peaks/macs3/{sample}_peaks.narrowPeak",
        peaks="peaks/macs3/{sample}_peaks.xls"
    log:
        "logs/call_macs_peaks/{sample}.log",
    conda:
        "envs/macs.yaml"
    params:
        prefix="{sample}",
        dir="peaks/macs3",
        has_igg=config["igg_control"],
    shell:
        """
        if [ {params.has_igg} == True ]; then
           macs3 callpeak -t {input.exp} -c {input.con} -f BAMPE -g hs -n "{params.prefix}" --outdir {params.dir} -B -q {config[macs3_qvalue_with_control]} || true
        else
           macs3 callpeak -t {input.exp} -f BAMPE -g hs -n "{params.prefix}" --outdir {params.dir} -B -q {config[macs3_qvalue_no_control]} --nolambda || true
        fi
        if [ ! -f {output.npeaks} ]; then 
            touch {output.sbed}
            touch {output.npeaks}
            touch {output.peaks}
        fi
        """

rule assess_peaks:
    input:
        peaks=expand("peaks/seacr/{sample}.peaks.stringent.bed", sample=EXPERIMENT),
        stats="stats/stats.txt",
    output:
        peakN="stats/seacr/peaks_num.txt",
        peakR="stats/seacr/peaks_reproducibility.txt",
        peakF="stats/seacr/peaks_frip.txt",
        fig="stats/seacr/peaks_fig.pdf",
    log:
        "logs/assess_seacr_peaks/job.log",
    conda:
        "envs/R.yaml"
    params:
        samplesheet=config["samplesheet"],
        subdir="dedupalignments" if config["dedup"] else "alignments",
        method="SEACR"
    script:
        "scripts/assess_peaks.R"

use rule assess_peaks as assess_macs_peaks with:
    input:
        peaks=expand("peaks/macs3/{sample}_peaks.narrowPeak", sample=EXPERIMENT),
        stats="stats/stats.txt",
    output:
        peakN="stats/macs3/peaks_num.txt",
        peakR="stats/macs3/peaks_reproducibility.txt",
        peakF="stats/macs3/peaks_frip.txt",
        fig="stats/macs3/peaks_fig.pdf",
    log:
        "logs/assess_macs_peaks/job.log",
    params:
        samplesheet=config["samplesheet"],
        subdir="dedupalignments" if config["dedup"] else "alignments",
        method="MACS"

rule consolidate_stats:
    input:
        seacr_num="stats/seacr/peaks_num.txt",
        seacr_reprod="stats/seacr/peaks_reproducibility.txt",
        seacr_frip="stats/seacr/peaks_frip.txt",
        macs3_num="stats/macs3/peaks_num.txt",
        macs3_reprod="stats/macs3/peaks_reproducibility.txt",
        macs3_frip="stats/macs3/peaks_frip.txt",
    output:
        consolidated="stats/peaks_consolidated.txt",
    log:
        "logs/consolidate_stats/job.log",
    conda:
        "envs/R.yaml"
    script:
        "scripts/consolidate_stats.R"

rule make_peak_heatmap:
    input:
        bam=(
            "dedupalignments/{sample}.sorted.bam"
            if config["dedup"]
            else "alignments/{sample}.sorted.bam"
        ),
        bai=(
            "dedupalignments/{sample}.sorted.bam.bai"
            if config["dedup"]
            else "alignments/{sample}.sorted.bam.bai"
        ),
        peaks="peaks/seacr/{sample}.peaks.stringent.bed",
    output:
        bw="alignments/{sample}_raw.bw",
        peaks=temp("peaks/seacr/{sample}.peaks.summitRegion.bed"),
        mat=temp("peaks/seacr/{sample}.mat.gz"),
        heatmap="stats/seacr/{sample}.heatmap.png",
    log:
        "logs/get_coverage/{sample}.log",
    conda:
        "envs/deeptools.yaml"
    threads: 2
    shell:
        """
        bamCoverage -b {input.bam} -o {output.bw}

        if [ -s {input.peaks} ]; then 
            awk '{{split($6, summit, ":"); split(summit[2], region, "-"); print summit[1]"\t"region[1]"\t"region[2]}}' {input.peaks} > {output.peaks} 

            computeMatrix reference-point \
              -S {output.bw} \
              -R {output.peaks} \
              --skipZeros \
              -o {output.mat} -p {threads} -a {config[heatmap_window]} -b {config[heatmap_window]} \
              --referencePoint center

            plotHeatmap -m {output.mat} -out {output.heatmap} --sortUsing sum \
            --startLabel "Peak Start" --endLabel "Peak End" \
            --xAxisLabel "" \
            --regionsLabel "Peaks" --samplesLabel "{wildcards.sample}"
        else
            touch {output.peaks}
            touch {output.mat}
            touch {output.heatmap} 
        fi
        """

onsuccess:
    shutil.rmtree(os.path.join(config["outdir"], "alignments"), ignore_errors=True)

